=== modified file 'controllers/default.py'
--- controllers/default.py	2010-06-04 23:11:55 +0000
+++ controllers/default.py	2010-06-06 09:09:51 +0000
@@ -32,6 +32,17 @@
     # Add newly-registered users to Person Registry & 'Authenticated' role
     auth.settings.register_onaccept = lambda form: auth.shn_register(form)
 
+    if request.args and request.args(0)=="login_next":
+        # The following redirects the user to contacts page on first login - can
+        # be updated for a workflow on login. This also notes the timestamp
+        # of last login through the browser
+        if auth.is_logged_in():
+            if not auth.user.timestamp:
+                db(db.auth_user.id == auth.user.id).update(timestamp = request.utcnow)
+                redirect(URL(r=request, c='msg', f='pe_contact'))
+            db(db.auth_user.id == auth.user.id).update(timestamp = request.utcnow)
+            redirect(URL(r=request, f='index'))
+
     if request.args and request.args(0)=="profile":
         #auth.settings.table_user.organisation.writable = False
         auth.settings.table_user.utc_offset.readable = True

=== modified file 'controllers/mobile.py'
--- controllers/mobile.py	2010-06-04 23:11:55 +0000
+++ controllers/mobile.py	2010-06-06 09:09:51 +0000
@@ -26,36 +26,29 @@
     return dict(module_name=module_name)
 
 @auth.requires_membership('Administrator')
-def setting():
+def settings():
     "Modem and Mobile related settings"
-    try:
-        import serial
-    except:
-        session.error = T('pyserial module not available within the running Python - this needs installing for SMS!')
-        redirect(URL(r=request, c='mobile', f='index' ))
     module = 'mobile'
-    resource = 'setting'
+    resource = 'settings'
     table = module + '_' + resource
 
     # Model options
-    db[table].port.comment = A(SPAN("[Help]"), _class="tooltip",
-        _title=T("Port|The serial port where your modem is connected."))
-    db[table].baud.comment = A(SPAN("[Help]"), _class="tooltip",
-        _title=T("Baud|The Baud rate of your modem - Usually listed in your modem manual."))
+    db[table].modem_port.comment = A(SPAN("[Help]"), _class="tooltip",
+        _title=T('Port|The serial port where your modem is connected.'))
+    db[table].modem_baud.comment = A(SPAN("[Help]"), _class="tooltip",
+        _title=T('Baud|The Baud rate of your modem - Usually listed in your modem manual.'))
     db[table].account_name.comment = A(SPAN("[Help]"), _class="tooltip",
-            _title=T("Account Name|Convenient name to identify the account."))
-    db[table].ip.comment = A(SPAN("[Help]"), _class="tooltip",
-            _title=T("IP|The server IP sending the message to Clickatell - Required for secure use of Clickatell account."))
+            _title=T('Account Name|Convenient name to identify the account.'))
     db[table].url.comment = A(SPAN("[Help]"), _class="tooltip",
-            _title=T("URL|The url for the Clickatell API."))
-    db[table].user.comment = A(SPAN("[Help]"), _class="tooltip",
-            _title=T("User|The username for the Clickatell account"))
-    db[table].api_id.comment = A(SPAN("[Help]"), _class="tooltip",
-            _title=T("API ID|The s/http api id generated through the Clickatell account."))
-    db[table].password.comment = A(SPAN("[Help]"), _class="tooltip",
-            _title=T("Password|The password for the ."))
-    db[table].sender_num.comment = A(SPAN("[Help]"), _class="tooltip",
-            _title=T("Sender Phone number|The sender phone number displayed with the SMS message ."))
+            _title=T('URL|The url for your gateway'))
+    db[table].parameters.comment = A(SPAN("[Help]"), _class="tooltip",
+            _title=T('Parameters|The parameters for gateway'))
+    db[table].message_variable.comment = A(SPAN("[Help]"), _class="tooltip",
+            _title=T('Message variable|The message variable used for the gateway'))
+    db[table].to_variable.comment = A(SPAN("[Help]"), _class="tooltip",
+            _title=T('To variable|The variable containing the phone number '))
+#    db[table].preference.comment = A(SPAN("[Help]"), _class="tooltip",
+#            _title=T('Preference|Prefered weight assigned to this gatway '))
 
     # CRUD Strings
     ADD_SETTING = T('Add Setting')

=== modified file 'controllers/msg.py' (properties changed: +x to -x)
--- controllers/msg.py	2010-06-04 23:50:19 +0000
+++ controllers/msg.py	2010-06-06 09:09:51 +0000
@@ -6,299 +6,171 @@
 
 module = 'msg'
 
+# Current Module (for sidebar title)
+module_name = db(db.s3_module.name==module).select().first().name_nice
 # Options Menu (available in all Functions' Views)
 response.menu_options = [
-    [T('Admin'), False, URL(r=request, f='admin')],
-    [T('Email'), False, URL(r=request, f='email'), [
-        [T('Send Email'), False, URL(r=request, f='email_outbox', args='create')],
-        [T('View Email InBox'), False, URL(r=request, f='email_inbox')],
-        [T('View Email OutBox'), False, URL(r=request, f='email_outbox')],
-        [T('View Sent Email'), False, URL(r=request, f='email_sent')],
-    ]],
-    [T('SMS'), False, URL(r=request, f='sms'), [
-        [T('Send SMS'), False, URL(r=request, f='sms_outbox', args='create')],
-        [T('View SMS InBox'), False, URL(r=request, f='sms_inbox')],
-        [T('View SMS OutBox'), False, URL(r=request, f='sms_outbox')],
-        [T('View Sent SMS'), False, URL(r=request, f='sms_sent')],
-    ]],
-    [T('Distribution Groups'), False, URL(r=request, f='group'), [
-    ]],
+	[T("Compose"), False, URL(r=request, f="outbox", args='create')],
+	[T("Outbox"), False, URL(r=request, f="outbox")],
+	[T('Distribution groups'), False, URL(r=request, f='group'), [
+		[T('List/Add'), False, URL(r=request, f='group')],
+		[T('Group Memberships'), False, URL(r=request, f='group_membership')], 
+	]],
     #[T('CAP'), False, URL(r=request, f='tbc')]
 ]
-
+if auth.has_membership(auth.id_group('Administrator')):
+	response.menu_options.append([T('Admin'), False, URL(r=request, f='admin')])
 # S3 framework functions
 def index():
     "Module's Home Page"
-    
-    module_name = db(db.s3_module.name == module).select().first().name_nice
-    
     return dict(module_name=module_name)
 
 def tbc():
     "Coming soon..."
     return dict(module_name=module_name)
 
-
 def admin():
-    # This can be set to a MessagingAdmin role, if-desired
-    if auth.has_membership(auth.id_group('Administrator')):
-        redirect(URL(r=request, f='setting', args=['update', 1]))
-    else:
-        redirect(URL(r=request, f='setting', args=['read', 1]))
+	redirect(URL(r=request, f='setting', args=['update', 1]))
 
 def setting():
     " RESTlike CRUD controller "
-    if request.args(0) == 'update' or request.args(0) == 'delete':
-        if not auth.has_membership(auth.id_group('Administrator')):
-            session.error = UNAUTHORISED
-            redirect(URL(r=request, f='index'))
+    if not auth.has_membership(auth.id_group('Administrator')):
+		session.error = UNAUTHORISED
+		redirect(URL(r=request, f='index'))
     return shn_rest_controller(module, 'setting', listadd=False, deletable=False)
 
-# SMS
-def sms():
-    " Simple page for showing links "
-    title = T('SMS')
-    return dict(title=title)
-def sms_inbox():
-    " RESTlike CRUD controller "
-    return shn_rest_controller(module, 'sms_inbox', listadd=False)
-def sms_outbox():
-    " RESTlike CRUD controller "
-    # Replace dropdown with an INPUT so that we can use the jQuery autocomplete plugin
-    db.msg_sms_outbox.msg_group_id.widget = lambda f, v: StringWidget.widget(f, v)
-    # Restrict list to just those of type 'sms'
-    # tbc
-    return shn_rest_controller(module, 'sms_outbox', listadd = False)
-def sms_sent():
-    " RESTlike CRUD controller "
-    return shn_rest_controller(module, 'sms_sent', listadd=False)
-
-# Email
-def email():
-    " Simple page for showing links "
-    title = T('Email')
-    return dict(title=title)
-
-def email_inbox():
-    " RESTlike CRUD controller "
-    # Is there an error from the polling script?
-    status = db().select(db.msg_email_inbound_status.ALL)
-    try:
-        response.warning = status[0].status
-        # Clear status
-        db(db.msg_email_inbound_status.id==status[0].id).delete()
-    except:
-        pass
-    return shn_rest_controller(module, 'email_inbox', listadd=False)
-
-def email_outbox():
-    " RESTlike CRUD controller "
-    # Replace dropdown with an INPUT so that we can use the jQuery autocomplete plugin
-    db.msg_email_outbox.msg_group_id.widget = lambda f, v: StringWidget.widget(f, v)
-    # Restrict list to just those of type 'email'
-    # tbc
-    return shn_rest_controller(module, 'email_outbox', listadd=False)
-def email_sent():
-    " RESTlike CRUD controller "
-    return shn_rest_controller(module, 'email_sent', listadd=False)
-
-def email_send():
-    """ Send Pending emails from OutBox.
-    If succesful then move from OutBox to Sent.
-    Designed to be called from Cron """
-
-    # Check database for pending mails
-    table = db.msg_email_outbox
-    query = table.id > 0
-    rows = db(query).select()
-
-    for row in rows:
-        subject = row.subject
-        message = row.body
-        # Determine list of users
-        group = row.msg_group_id
-        table2 = db.msg_group_user
-        query = table2.msg_group_id == group
-        recipients = db(query).select()
-        for recipient in recipients:
-            to = db(db.pr_person.id==recipient.person_id).select().first().email
-            # If the user has an email address
-            if to:
-                # Use Tools API to send mail
-                status = mail.send(to, subject, message)
-        # We only check status of last recipient
-        if status:
-            # Add message to Sent
-            db.msg_email_sent.insert(created_by=row.created_by, modified_by=row.modified_by, uuid=row.uuid, group_id=group, subject=subject, body=message)
-            # Delete from OutBox
-            db(table.id==row.id).delete()
-            # Explicitly commit DB operations when running from Cron
-            db.commit()
-    return
-
-
-# Contacts
+#--------------------------------------------------------------------------------------------------
+
+# The following 2 functions hook into the pr functions
+# -----------------------------------------------------------------------------
 def group():
-    " RESTlike CRUD controller "
-    # If we know which record we're editing
-    if len(request.args) == 2:
-        crud.settings.update_next = URL(r=request, f='group_user', args=request.args(1))
-    return shn_rest_controller(module, 'group')
-
-def group_user():
-    "Many to Many CRUD Controller"
-    if len(request.args) == 0:
-        session.error = T("Need to specify a group!")
-        redirect(URL(r=request, f='group'))
-    group = request.args(0)
-    table = db.msg_group_user
-    authorised = shn_has_permission('update', table)
-
-    title = db.msg_group[group].name
-    group_description = db.msg_group[group].comments
-    _group_type = db.msg_group[group].group_type
-    group_type = msg_group_type_opts[_group_type]
-    query = table.msg_group_id==group
-    # Start building the Return with the common items
-    output = dict(title=title, description=group_description, group_type=group_type)
-    # Audit
-    shn_audit_read(operation='list', module="msg" ,resource='group_user', record=group, representation='html')
-    item_list = []
-    sqlrows = db(query).select()
-    even = True
-    if authorised:
-        # Audit
-        crud.settings.create_onaccept = lambda form: shn_audit_create(form, module, 'group_user', 'html')
-        # Display a List_Create page with deletable Rows
-        for row in sqlrows:
-            if even:
-                theclass = "even"
-                even = False
-            else:
-                theclass = "odd"
-                even = True
-            id = row.person_id
-            name = db.pr_person[id].first_name + ' ' + db.pr_person[id].last_name
-            preferred = db.pr_person[id].preferred_name
-            id_link = A(id, _href=URL(r=request, c='pr', f='person', args=['read', id]))
-            checkbox = INPUT(_type="checkbox", _value="on", _name=id, _class="remove_item")
-            item_list.append(TR(TD(id_link), TD(name, _align='left'), TD(preferred, _align='left'), TD(checkbox, _align='center'), _class=theclass, _align='right'))
-
-        table_header = THEAD(TR(TH('ID'), TH(table.person_id.label), TH(T('Preferred Name')), TH(T('Remove'))))
-        table_footer = TFOOT(TR(TD('', _colspan=3), TD(INPUT(_id='submit_button', _type='submit', _value=T('Update')))), _align='right')
-        items = DIV(FORM(TABLE(table_header, TBODY(item_list), table_footer, _id="table-container"), _name='custom', _method='post', _enctype='multipart/form-data', _action=URL(r=request, f='group_update_users', args=[group])))
-        subtitle = T("Contents")
-
-        crud.messages.submit_button=T('Add')
-        # Do Checks before User is added to Group: Duplicates & Email/SMS fields available
-        crud.settings.create_onvalidation = lambda form: group_validation(form)
-        crud.messages.record_created = T('Group Updated')
-        form = crud.create(table, next=URL(r=request, args=[group]))
-        addtitle = T("Add New User to Group")
-        response.view = '%s/group_user_list_create.html' % module
-        output.update(dict(subtitle=subtitle, items=items, addtitle=addtitle, form=form, group=group))
-    else:
-        # Display a simple List page
-        for row in sqlrows:
-            if even:
-                theclass = "even"
-                even = False
-            else:
-                theclass = "odd"
-                even = True
-            id = row.person_id
-            name = db.pr_person[id].first_name + ' ' + db.pr_person[id].last_name
-            preferred = db.pr_person[id].preferred_name
-            id_link = A(id, _href=URL(r=request, c='pr', f='person', args=['read', id]))
-            item_list.append(TR(TD(id_link), TD(name, _align='left'), TD(preferred, _align='left'), _class=theclass, _align='right'))
-
-        table_header = THEAD(TR(TH('ID'), TH(table.person_id.label), TH(T('Preferred Name'))))
-        items = DIV(TABLE(table_header, TBODY(item_list), _id="table-container"))
-        add_btn = A(T('Edit Contents'), _href=URL(r=request, c='default', f='user', args='login'), _class="action-btn")
-        response.view = '%s/group_user_list.html' % module
-        output.update(dict(items=items, add_btn=add_btn))
-    return output
-
-def group_validation(form):
-    """Do Checks before User added to Group:
-    * Not a duplicate
-    * User has Email &/or SMS fields available
-    """
-    group = form.vars.msg_group_id
-    user = form.vars.person_id
-    # Check for Duplicates
-    table = db.msg_group_user
-    query = (table.msg_group_id==group) & (table.person_id==user)
-    items = db(query).select()
-    if items:
-        session.error = T("User already in Group!")
-        redirect(URL(r=request, args=group))
-    else:
-        # Which type of Group is this?
-        table = db.msg_group
-        query = table.id==group
-        group_type = db(query).select().first().group_type
-        table = db.pr_person
-        query = table.id==user
-        email = db(query).select().first().email
-        sms = db(query).select().first().mobile_phone
-        session.warning = ''
-        # type 1 = Email
-        # type 3 = Both
-        if group_type == 1 or group_type == 3:
-            # Check that Email field populated
-            if not email:
-                session.warning += str(T("User has no Email address!"))
-        # type 2 = SMS
-        if group_type == 2 or group_type == 3:
-            # Check that SMS field populated
-            if not sms:
-                session.warning += str(T("User has no SMS address!"))
-        return
-
-def group_update_users():
-    "Update a Group's members (Delete)"
-    if len(request.args) == 0:
-        session.error = T("Need to specify a group!")
-        redirect(URL(r=request, f='group'))
-    group = request.args(0)
-    table = db.msg_group_user
-    authorised = shn_has_permission('update', table)
-    if authorised:
-        for var in request.vars:
-            user = var
-            query = (table.msg_group_id==group) & (table.person_id==user)
-            db(query).delete()
-        # Audit
-        shn_audit_update_m2m(resource='group_user', module = 'msg', record=group, representation='html')
-        session.flash = T("Group updated")
-    else:
-        session.error = T("Not authorised!")
-    redirect(URL(r=request, f='group_user', args=[group]))
-
-def group_search():
+    response.s3.filter = (db.pr_group.system==False) # do not show system groups
+    response.s3.pagination = True
+    "RESTlike CRUD controller"
+    return shn_rest_controller('pr', "group",
+                               main="group_name",
+                               extra="group_description",
+                               pheader=shn_pr_pheader,
+                               deletable=False)
+# -----------------------------------------------------------------------------
+def group_membership():
+    "RESTlike CRUD controller"
+    return shn_rest_controller('pr', "group_membership")
+
+#-------------------------------------------------------------------------------
+
+def pe_contact():
+    """ Allows the user to add,update and delete his contacts"""
+    if auth.is_logged_in() or auth.basic():
+        person = (db(db.pr_person.uuid==auth.user.person_uuid).select(db.pr_person.pr_pe_id))[0].pr_pe_id
+        response.s3.filter = (db.pr_pe_contact.pr_pe_id == person)
+    else:
+        redirect(URL(r=request, c='default', f='user', args='login',
+            vars={'_next':URL(r=request, c='msg', f='pe_contact')}))
+
+    db.pr_pe_contact.name.writable = False
+    db.pr_pe_contact.name.readable = False
+    db.pr_pe_contact.id.writable = False
+#   db.pr_pe_contact.id.readable = False
+    db.pr_pe_contact.pr_pe_id.writable = False
+    db.pr_pe_contact.pr_pe_id.readable = False
+    db.pr_pe_contact.person_name.writable = False
+    db.pr_pe_contact.person_name.readable = False
+    def msg_pe_contact_onvalidation(form):
+        """This onvalidation method adds the person id to the record"""
+        person = (db(db.pr_person.uuid == auth.user.person_uuid).select(db.pr_person.pr_pe_id))[0].pr_pe_id
+        form.vars.pr_pe_id = person
+    def msg_pe_contact_restrict_access(jr):
+        """The following restricts update and delete access to contacts not
+        owned by the user"""
+        if jr.id :
+            person = (db(db.pr_person.uuid == auth.user.person_uuid).select(db.pr_person.pr_pe_id))[0].pr_pe_id
+            if person == (db(db.pr_pe_contact.id == jr.id).select(db.pr_pe_contact.pr_pe_id))[0].pr_pe_id :
+                return True
+            else:
+                session.error = T("Access denied")
+                return dict(bypass = True, output = redirect(URL(r=request)))
+        else:
+            return True
+    s3xrc.model.configure(db.pr_pe_contact,
+            onvalidation=lambda form: msg_pe_contact_onvalidation(form))
+    response.s3.prep = msg_pe_contact_restrict_access
+    response.menu_options = []
+    return shn_rest_controller('pr', 'pe_contact', listadd=True)
+
+#-------------------------------------------------------------------------------
+
+def search():
     """Do a search of groups which match a type
     Used for auto-completion
     """
-    item = ''
-    if not 'type' in request.vars:
-        item = '{"Status":"failed","Error":{"StatusCode":501,"Message":"Search requires specifying Type!"}}'
-    if request.vars.type == 'email':
-            # Types 'Email' & 'Both'
-            belongs = (1, 3)
-    elif request.vars.type == 'sms':
-            # Types 'SMS' & 'Both'
-            belongs = (2, 3)
+    import json as original_json #get the json lib
+    table1 = db.pr_group
+    field1 = 'group_name'
+    table2 = db.pr_person
+    field21 = 'first_name'
+    field22 = 'middle_name'
+    field23 = 'last_name'
+    # JQuery Autocomplete uses 'q' instead of 'value'
+    value = request.vars.q
+    if value:
+		item = []
+		query = db((table1[field1].like('%' + value + '%'))).select(db.pr_group.pr_pe_id)
+		for row in query:
+			item.append({'id':row.pr_pe_id,'name':shn_pentity_represent(row.pr_pe_id, default_label = '')})
+		query = db((table2[field21].like('%' + value + '%'))).select(db.pr_person.pr_pe_id)
+		for row in query:
+			item.append({'id':row.pr_pe_id,'name':shn_pentity_represent(row.pr_pe_id, default_label = '')})
+		query = db((table2[field22].like('%' + value + '%'))).select(db.pr_person.pr_pe_id)
+		for row in query:
+			item.append({'id':row.pr_pe_id,'name':shn_pentity_represent(row.pr_pe_id, default_label = '')})
+		query = db((table2[field23].like('%' + value + '%'))).select(db.pr_person.pr_pe_id)
+		for row in query:
+			item.append({'id':row.pr_pe_id,'name':shn_pentity_represent(row.pr_pe_id, default_label = '')})
+		item = original_json.dumps(item)
+		response.view = 'plain.html'
+		return dict(item=item)
+    return
+#-------------------------------------------------------------------------------
+def outbox():
+    "RESTlike CRUD controller"
+    if auth.is_logged_in() or auth.basic():
+        if auth.has_membership(1):
+            pass
+        else:
+            person = (db(db.pr_person.uuid==auth.user.person_uuid).select(db.pr_person.id))[0].id
+            db.msg_outbox.id.readable = False
+            response.s3.filter = (db.msg_outbox.person_id == person)
     else:
-        item = '{"Status":"failed","Error":{"StatusCode":501,"Message":"Unsupported type! Supported types: email, sms"}}'
-    if not item:
-        table = db.msg_group
-        field = 'name'
-        # JQuery Autocomplete uses 'q' instead of 'value'
-        value = request.vars.q
-        # JOIN bad for GAE
-        query = (table[field].like('%' + value + '%')) & (table['group_type'].belongs(belongs))
-        item = db(query).select().json()
-
-    response.view = 'plain.html'
-    return dict(item=item)
+        redirect(URL(r=request, c='default', f='user', args='login',
+            vars={'_next':URL(r=request, c='msg', f='pe_contact')}))
+
+    def restrict_methods(jr):
+		if jr.method == 'create':
+			db.msg_outbox.pr_pe_id.widget = lambda f, v: StringWidget.widget(f, v)
+			return True
+		if jr.method == 'delete' or jr.method == 'update':
+			if auth.has_membership(1):
+				return True
+			else:
+				session.error = T('Restricted method')
+				return dict(bypass = True, output = redirect(URL(r=request)))
+		else:
+			return True
+    def msg_outbox_onvalidation(form):
+        """This onvalidation method adds the person id to the record"""
+        person = (db(db.pr_person.uuid == auth.user.person_uuid).select(db.pr_person.id))[0].id
+        form.vars.person_id = person
+        if not form.vars.pr_pe_id:
+			session.error = T('Empty Recipients')
+			redirect(URL(r=request,c='msg', f='outbox', args='create'))
+    db.msg_outbox.status.writable = False
+    db.msg_outbox.status.readable = True
+    db.msg_outbox.person_id.readable = False
+    db.msg_outbox.person_id.writable = False
+    response.s3.prep = restrict_methods
+    s3xrc.model.configure(db.msg_outbox,
+            onvalidation=lambda form: msg_outbox_onvalidation(form))
+    return shn_rest_controller('msg', "outbox", listadd=False)
+
+#-------------------------------------------------------------------------------

=== modified file 'controllers/pr.py'
--- controllers/pr.py	2010-06-04 23:11:55 +0000
+++ controllers/pr.py	2010-06-06 09:09:51 +0000
@@ -20,6 +20,7 @@
         [T("Groups"), False, URL(r=request, f="group"), [
             [T("List"), False, URL(r=request, f="group")],
             [T("Add"), False, URL(r=request, f="group", args="create")],
+			[T("Group Memberships"), False, URL(r=request, f="group_membership")], 
         ]]]
     if session.rcvars and "pr_person" in session.rcvars:
         selection = db.pr_person[session.rcvars["pr_person"]]

=== modified file 'cron/crontab'
--- cron/crontab	2010-05-03 02:11:51 +0000
+++ cron/crontab	2010-06-06 09:09:51 +0000
@@ -3,8 +3,9 @@
 #@reboot root *applications/sahana/cron/1st_run.py
 # AutoSync daemon running ZeroConf should be launched at startup
 #@reboot root **applications/sahana/cron/daemonX.py
-# SMS handler daemon should be launched at startup
-#@reboot root *applications/sahana/cron/sms_handler.py
+# Messaging daemon should be launched at startup
+#@reboot root *applications/eden/cron/sms_handler_api.py
+#@reboot root *applications/eden/cron/email_handler_api.py
 # Send outgoing emails every 5 minutes
 #*/5   *       *       *       *       root *msg/email_send
 #*/5   *       *       *       *       root web2py.exe -S sahana/msg/email_send

=== added file 'cron/email_handler_api.py'
--- cron/email_handler_api.py	1970-01-01 00:00:00 +0000
+++ cron/email_handler_api.py	2010-06-06 09:09:51 +0000
@@ -0,0 +1,46 @@
+# -*- coding: utf-8 -*-
+# vim: ai ts=4 sts=4 et sw=4 encoding=utf-8
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be
+# included in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+
+__doc__ = \
+"""
+This is the async cron daemon for handling outgoing Email.
+
+"""
+
+__author__ = "Praneeth Bodduluri <lifeeth[at]gmail.com>"
+
+import urllib
+import time
+import sys, os
+path = os.path.join(request.folder, 'modules')
+if not path in sys.path:
+            sys.path.append(path)
+
+import s3msg
+msg = s3msg.Msg(globals(), db, T, mail)
+
+while 1:
+	msg.process_outbox(contact_method = 1)
+	time.sleep(15)
+	#For testing
+	#msg.send_sms_via_api("lifeeth@gmail.com","Subject","Body message")

=== added file 'cron/sms_handler_api.py'
--- cron/sms_handler_api.py	1970-01-01 00:00:00 +0000
+++ cron/sms_handler_api.py	2010-06-06 09:09:51 +0000
@@ -0,0 +1,47 @@
+# -*- coding: utf-8 -*-
+# vim: ai ts=4 sts=4 et sw=4 encoding=utf-8
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be
+# included in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+
+__doc__ = \
+"""
+This is the async cron daemon for handling outgoing SMS.
+
+"""
+
+__author__ = "Praneeth Bodduluri <lifeeth[at]gmail.com>"
+
+import urllib
+import time
+import sys, os
+path = os.path.join(request.folder, 'modules')
+if not path in sys.path:
+            sys.path.append(path)
+
+import s3msg
+msg = s3msg.Msg(globals(), db, T)
+
+if msg.sms_api_enabled:
+	while 1:
+		time.sleep(10)
+		msg.process_outbox(contact_method = 2)
+	#For testing
+	#msg.send_sms_via_api(9935648569,"Hello")
\ No newline at end of file

=== renamed file 'cron/sms_handler.py' => 'cron/sms_handler_modem.py'
--- cron/sms_handler.py	2010-05-04 17:52:20 +0000
+++ cron/sms_handler_modem.py	2010-06-06 09:09:51 +0000
@@ -1,69 +1,65 @@
 # -*- coding: utf-8 -*-
 # vim: ai ts=4 sts=4 et sw=4 encoding=utf-8
-
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be
+# included in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+
+__doc__ = \
+"""
+Module to spawn modem connectivity
+
+"""
+
+__author__ = "Praneeth Bodduluri <lifeeth[at]gmail.com>"
+
+import sys, os
+path = os.path.join(request.folder, 'modules')
+if not path in sys.path:
+            sys.path.append(path)
 import pygsm
 import threading
 import time
 from pygsm.autogsmmodem import GsmModemNotFound
-
-'''
-  Module to spawn modem connectivity
-'''
-
+import s3msg
 
 class ModemThread( threading.Thread ):
 	def __init__(self,modem):
 		self.modem = modem
 		threading.Thread.__init__ ( self )
-	def send_sms(self):
-		"""Send Pending SMS from OutBox.
-		If succesful then move from OutBox to Sent. A modified copy of send_email"""
-		 # Check database for pending mails
-		table = db.msg_sms_outbox
-		query = table.id > 0
-		rows = db(query).select()
-
-		for row in rows:
-			contents = row.contents
-			# Determine list of users
-			group = row.msg_group_id
-			table2 = db.msg_group_user
-			query = table2.msg_group_id == group
-			recipients = db(query).select()
-			status = True
-			for recipient in recipients:
-				to = db(db.pr_person.id==recipient.person_id).select().first().mobile_phone
-				if to:
-					try:
-						self.modem.send_sms(to, contents)
-					except:
-						status = False
-			# We only check status of last recipient
-			if status:
-				# Add message to Sent
-				db.msg_sms_sent.insert(created_by=row.created_by, modified_by=row.modified_by, uuid=row.uuid, msg_group_id=group, contents=contents)
-				# Delete from OutBox
-				db(table.id==row.id).delete()
-				# Explicitly commit DB operations when running from Cron
-				db.commit()
-		return
-		
+		self.msg = s3msg.Msg(globals(), db, T, modem = modem)
 	def run(self):
 		while True:
-			self.send_sms()
-			time.sleep(2)
+			self.msg.process_outbox(contact_method = 2, option = 2)
+			time.sleep(20)
 			pass
 		#self.modem.send_sms("9935648569","Hey!")
 
 
-modem_configs = db(db.mobile_setting.port != "").select()
+modem_configs = db(db.mobile_settings.modem_port != "").select()
 
 # PyGSM GsmModem class instances
 modems=[]
 
 for modem in modem_configs:
     # mode is set to text as PDU mode is flaky
-    modems.append(pygsm.GsmModem(port=modem.port, baudrate=modem.baud, mode="text")) 
+    modems.append(pygsm.GsmModem(port=modem.modem_port, baudrate=modem.modem_baud, mode="text")) 
 
 if len(modems) == 0:
     # If no modem is found try autoconfiguring
@@ -75,4 +71,4 @@
 
 # Starting a thread for each modem we have
 for modem in modems:
-	ModemThread(modem).run()
\ No newline at end of file
+	ModemThread(modem).run()

=== modified file 'models/00_db.py'
--- models/00_db.py	2010-06-04 23:50:19 +0000
+++ models/00_db.py	2010-06-06 09:09:51 +0000
@@ -17,17 +17,10 @@
 # (need to set to "True" again when amending Table definitions)
 migrate = True
 
-#if request.env.web2py_runtime_gae:            # if running on Google App Engine
-#    db = DAL("gae")                           # connect to Google BigTable
-#    session.connect(request, response, db=db) # and store sessions and tickets there
-    ### or use the following lines to store sessions in Memcache
-    # from gluon.contrib.memdb import MEMDB
-    # from google.appengine.api.memcache import Client
-    # session.connect(request, response, db=MEMDB(Client())
-#else:                                         # else use a normal relational database
-db = DAL("sqlite://storage.db")       # if not, use SQLite or other DB
-#db = DAL("mysql://sahana:password@localhost/sahana", pool_size=30) # or other DB
+db = DAL("sqlite://storage.db")       # Use SQLite or other DB
+#db = DAL("mysql://sahana:password@localhost/sahana", pool_size=30)
 #db = DAL("postgres://postgres:password@localhost/db", pool_size=10)
+#session.connect(request, response, db=db) # Store sessions and tickets in DB
 
 ##################################
 # Instantiate Classes from Modules

=== modified file 'models/00_settings.py'
--- models/00_settings.py	2010-05-25 21:14:47 +0000
+++ models/00_settings.py	2010-06-06 09:09:51 +0000
@@ -83,6 +83,10 @@
 auth.settings.lock_keys = False
 auth.settings.logout_onlogout = shn_auth_on_logout
 auth.settings.login_onaccept = shn_auth_on_login
+auth.settings.login_next = URL(r=request, c='default', f='user',
+        args='login_next')
+auth.settings.register_next = URL(r=request, c='default', f='user',
+        args='login_next')
 
 # Extra startup roles for Admin:
 auth.settings.admin_startup_roles = [

=== modified file 'models/01_menu.py'
--- models/01_menu.py	2010-05-25 21:14:47 +0000
+++ models/01_menu.py	2010-06-06 09:09:51 +0000
@@ -38,6 +38,8 @@
                  URL(request.application, "default", "user/logout")],
                 [T("Edit Profile"), False,
                  URL(request.application, "default", "user/profile")],
+                [T("My contact details"), False,
+                 URL(request.application, "msg", "pe_contact")],
                 [T("Change Password"), False,
                  URL(request.application, "default", "user/change_password")]]
          ]
@@ -65,7 +67,7 @@
             [T("Sync Settings"), False, URL(r=request, c="sync", f="setting", args=["update", 1])]
     ]],
     [T("Mobile"), False, URL(r=request, c="mobile", f="index"),[
-            [T("Mobile Settings"), False, URL(r=request, c="mobile", f="setting", args=["update", 1])]
+            [T("Mobile Settings"), False, URL(r=request, c="mobile", f="settings", args=["update", 1])]
     ]],
     [T("Edit Application"), False, URL(r=request, a="admin", c="default", f="design", args=[request.application])],
     [T("Tickets"), False, URL(r=request, c="admin", f="errors")],

=== modified file 'models/02_pr.py'
--- models/02_pr.py	2010-06-04 23:50:19 +0000
+++ models/02_pr.py	2010-06-06 09:09:51 +0000
@@ -33,7 +33,7 @@
 
 # -----------------------------------------------------------------------------
 #
-def shn_pentity_represent(id):
+def shn_pentity_represent(id,default_label="[no label]"):
 
     """
         Represent a Person Entity in option fields or list views
@@ -49,7 +49,7 @@
     if not pentity:
         return default
     entity_type = pentity.opt_pr_entity_type
-    label = pentity.label or "no label"
+    label = pentity.label or default_label
 
     etype = lambda entity_type: vita.trackable_types[entity_type]
 
@@ -62,7 +62,7 @@
                     limitby=(0, 1))
         if person:
             person = person[0]
-            pentity_str = "%s [%s] (%s)" % (
+            pentity_str = "%s %s (%s)" % (
                 vita.fullname(person),
                 label,
                 etype(entity_type)

=== modified file 'models/04_pr.py'
--- models/04_pr.py	2010-05-29 21:33:01 +0000
+++ models/04_pr.py	2010-06-06 09:09:51 +0000
@@ -87,11 +87,11 @@
 #
 pr_contact_method_opts = {
     1:T("E-Mail"),
-    2:T("Telephone"),
-    3:T("Mobile Phone"),
-    4:T("Fax"),
-    5:T("Twitter"),
-    6:T("XMPP"),
+    2:T("Mobile Phone"),
+    3:T("XMPP"),
+    4:T("Twitter"),
+    5:T("Telephone"),
+    6:T("Fax"),
     99:T("other")
     }
 

=== modified file 'models/mobile.py'
--- models/mobile.py	2010-05-03 02:11:51 +0000
+++ models/mobile.py	2010-06-06 09:09:51 +0000
@@ -7,19 +7,24 @@
 module = 'mobile'
 
 # Settings
-resource = 'setting'
+resource = 'settings'
 tablename = "%s_%s" % (module, resource)
 table = db.define_table(tablename,
-                Field('port'),                              # Port for the modem
-                Field('baud', 'integer', default = 115200), # Modem Baud rate
                 Field('account_name'), # Nametag to remember account
-                Field('url', default = 'https://api.clickatell.com/http/sendmsg'), # URL for Clickatell
-                Field('ip', default = ''), # [Optional] IP address for the server
-                Field('user'), # Clickatell account username
-                Field('api_id', 'integer', default = ''), # Clickatell generated s/http id
-                Field('password', 'string', default = ''), # Clickatell password
-                Field('sender_num', 'integer', default = ''), # Sender phone number
+                Field('modem_port'),                              # Port for the modem
+                Field('modem_baud', 'integer', default = 115200), # Modem Baud rate
+                Field('url', default = 'https://api.clickatell.com/http/sendmsg'), # URL for Gateway
+                Field('parameters', default =\
+                    'user=yourusername&password=yourpassword&api_id=yourapiid'), # Other Parameters
+                Field('message_variable', 'string', default = 'text'), # Variable for message
+                Field('to_variable', 'string', default = 'to'), # Variable for message
+                Field('enabled', 'boolean', default = True), # Variable for message
+#                Field('preference', 'integer', default = 5), # Weight for the setting
                 migrate=migrate)
+table.to_variable.label = T('To variable')
+table.message_variable.label = T('Message variable')
+table.modem_port.label = T('Port')
+table.modem_baud.label = T('Baud')
 
 # SMS store for persistence and scratch pad for combining incoming xform chunks
 resource = 'store'

=== modified file 'models/msg.py'
--- models/msg.py	2010-05-23 21:10:57 +0000
+++ models/msg.py	2010-06-06 09:09:51 +0000
@@ -36,245 +36,56 @@
                     Field('status'),
                     migrate=migrate)
 
-    # Group
-    msg_group_type_opts = {
-        1:T('Email'),
-        2:T('SMS'),
-        3:T('Both')
+
+    # Valid message outbox status'
+    msg_status_type_opts = {
+        1:T('Unsent'),
+        2:T('Sent'),
+        3:T('Draft'),
+        4:T('Invalid')
         }
-    opt_msg_group_type = db.Table(None, 'opt_msg_group_type',
-                        Field('group_type', 'integer', notnull=True,
-                        requires = IS_IN_SET(msg_group_type_opts),
-                        # default = 1,
-                        label = T('Type'),
-                        represent = lambda opt: msg_group_type_opts.get(opt, UNKNOWN_OPT)))
-
-    resource = 'group'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, uuidstamp, deletion_status,
-                    Field('name', notnull=True),
-                    opt_msg_group_type,
-                    Field('comments'),
-                    migrate=migrate)
-    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
-    table.name.requires = IS_NOT_EMPTY()
-    table.name.label = T('Name')
-    table.name.comment = SPAN("*", _class="req")
-    table.comments.label = T('Comments')
-    ADD_GROUP = T('Add Group')
-    LIST_GROUP = T('List Groups')
-    s3.crud_strings[tablename] = Storage(
-        title_create = ADD_GROUP,
-        title_display = T('Group Details'),
-        title_list = LIST_GROUP,
-        title_update = T('Edit Group'),
-        title_search = T('Search Groups'),
-        subtitle_create = T('Add New Group'),
-        subtitle_list = T('Groups'),
-        label_list_button = LIST_GROUP,
-        label_create_button = ADD_GROUP,
-        msg_record_created = T('Group added'),
-        msg_record_modified = T('Group updated'),
-        msg_record_deleted = T('Group deleted'),
-        msg_list_empty = T('No Groups currently registered'))
-    # Reusable field for other tables to reference
-    msg_group_id = db.Table(None, 'msg_group_id',
-                FieldS3('msg_group_id', db.msg_group, sortby='name',
-                    requires = IS_ONE_OF(db, 'msg_group.id', '%(name)s'),
-                    represent = lambda id: (id and [db(db.msg_group.id==id).select()[0].name] or ["None"])[0],
-                    label = T('Group'),
-                    comment = DIV(A(T('Add Group'), _class='colorbox', _href=URL(r=request, c='msg', f='group', args='create', vars=dict(format='popup')), _target='top', _title=T('Add Group')), A(SPAN("[Help]"), _class="tooltip", _title=T("Distribution Group|The Group of People to whom this Message should be sent."))),
-                    ondelete = 'RESTRICT'
-                    ))
-
-    # Group<>User Many2Many
-    resource = 'group_user'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, deletion_status,
-                    Field('msg_group_id', db.msg_group),
+
+    opt_msg_status = db.Table(None, 'opt_msg_status',
+                        Field('status', 'integer', notnull=True,
+                        requires = IS_IN_SET(msg_status_type_opts),
+                        default = 1,
+                        label = T('Status'),
+                        represent = lambda opt: msg_status_type_opts.get(opt, UNKNOWN_OPT)))
+
+	# Person entity outbox - Should be extended for non pr_pe_id type resources
+    resource = 'outbox'
+    tablename = "%s_%s" % (module, resource)
+    table = db.define_table(tablename, timestamp, authorstamp, uuidstamp, deletion_status,
+                    pr_pe_id,
                     person_id,
-                    migrate=migrate)
-    table.msg_group_id.requires = IS_ONE_OF(db, 'msg_group.id', '%(name)s')
-    table.msg_group_id.represent = lambda msg_group_id: db(db.msg_group.id==msg_group_id).select()[0].name
-    table.person_id.label = T('User')
-
-    # Incoming SMS
-    resource = 'sms_inbox'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, uuidstamp, deletion_status,
-                    Field('phone_number', 'integer', notnull=True),
-                    Field('contents', length=700),  # length=140 omitted to handle multi-part SMS
-                    #Field('smsc', 'integer'),
-                    migrate=migrate)
-    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
-    table.phone_number.requires = IS_NOT_EMPTY()
-    table.phone_number.label = T('Phone Number')
-    #table.phone_number.comment = SPAN("*", _class="req")
-    table.contents.label = T('Contents')
-    VIEW_SMS_INBOX = T('View SMS InBox')
-    s3.crud_strings[tablename] = Storage(
-        #title_create = T('Add Incoming SMS'),
-        title_display = T('SMS Details'),
-        title_list = VIEW_SMS_INBOX,
-        #title_update = T('Edit SMS'),
-        title_search = T('Search SMS InBox'),
-        subtitle_list = T('SMS InBox'),
-        label_list_button = VIEW_SMS_INBOX,
-        #label_create_button = T('Add Incoming SMS'),
-        #msg_record_created = T('SMS added'),
-        #msg_record_modified = T('SMS updated'),
-        msg_record_deleted = T('SMS deleted'),
-        msg_list_empty = T('No SMS\'s currently in InBox'))
-
-    # Outgoing SMS
-    resource = 'sms_outbox'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, authorstamp, uuidstamp, deletion_status,
-                    #Field('phone_number', 'integer', notnull=True),
-                    msg_group_id,
-                    Field('contents', length=700),  # length=140 omitted to handle multi-part SMS
-                    #Field('smsc', 'integer'),
-                    migrate=migrate)
-    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
-    #table.phone_number.requires = IS_NOT_EMPTY()
-    #table.phone_number.comment = SPAN("*", _class="req")
-    table.contents.comment = A(SPAN("[Help]"), _class="tooltip", _title=T("Contents|If this is over 140 characters then it will be split into Multiple SMS's."))
-    table.msg_group_id.label = T('Recipients')
-    table.contents.label = T('Contents')
-    SEND_SMS = T('Send SMS')
-    VIEW_SMS_OUTBOX = T('View SMS OutBox')
-    s3.crud_strings[tablename] = Storage(
-        title_create = SEND_SMS,
-        title_display = T('SMS Details'),
-        title_list = VIEW_SMS_OUTBOX,
-        title_update = T('Edit SMS'),
-        title_search = T('Search SMS OutBox'),
-        subtitle_create = SEND_SMS,
-        subtitle_list = T('SMS OutBox'),
-        label_list_button = VIEW_SMS_OUTBOX,
-        label_create_button = T('Send SMS'),
-        msg_record_created = T('SMS created'),
-        msg_record_modified = T('SMS updated'),
-        msg_record_deleted = T('SMS deleted'),
-        msg_list_empty = T('No SMS\'s currently in OutBox'))
-
-    resource = 'sms_sent'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, authorstamp, uuidstamp, deletion_status,
-                    #Field('phone_number', 'integer', notnull=True),
-                    msg_group_id,
-                    Field('contents', length=700),  # length=140 omitted to handle multi-part SMS
-                    #Field('smsc', 'integer'),
-                    migrate=migrate)
-    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
-    #table.phone_number.requires = IS_NOT_EMPTY()
-    #table.phone_number.comment = SPAN("*", _class="req")
-    table.msg_group_id.label = T('Recipients')
-    table.contents.label = T('Contents')
-    VIEW_SENT_SMS = T('View Sent SMS')
-    s3.crud_strings[tablename] = Storage(
-        #title_create = T('Send SMS'),
-        title_display = T('SMS Details'),
-        title_list = VIEW_SENT_SMS,
-        #title_update = T('Edit SMS'),
-        title_search = T('Search Sent SMS'),
-        #subtitle_create = T('Send SMS'),
-        subtitle_list = T('Sent SMS'),
-        label_list_button = VIEW_SENT_SMS,
-        #label_create_button = T('Send SMS'),
-        #msg_record_created = T('SMS created'),
-        #msg_record_modified = T('SMS updated'),
-        msg_record_deleted = T('SMS deleted'),
-        msg_list_empty = T('No SMS\'s currently in Sent'))
-
-    # Incoming Email
-    resource = 'email_inbox'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, uuidstamp, deletion_status,
-                    Field('sender', notnull=True),
-                    Field('subject', length=78),    # RFC 2822
-                    Field('body', 'text'),
-                    migrate=migrate)
-    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
-    table.sender.requires = IS_EMAIL()
-    table.sender.label = T('Sender')
-    #table.sender.comment = SPAN("*", _class="req")
-    table.subject.label = T('Subject')
-    table.body.label = T('Body')
-    VIEW_EMAIL_INBOX = T('View Email InBox')
-    s3.crud_strings[tablename] = Storage(
-        #title_create = T('Add Incoming Email'),
-        title_display = T('Email Details'),
-        title_list = VIEW_EMAIL_INBOX,
-        #title_update = T('Edit Email'),
-        title_search = T('Search Email InBox'),
-        subtitle_list = T('Email InBox'),
-        label_list_button = VIEW_EMAIL_INBOX,
-        #label_create_button = T('Add Incoming Email'),
-        #msg_record_created = T('Email added'),
-        #msg_record_modified = T('Email updated'),
-        msg_record_deleted = T('Email deleted'),
-        msg_list_empty = T('No Emails currently in InBox'))
-
-    # Outgoing Email
-    resource = 'email_outbox'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, authorstamp, uuidstamp, deletion_status,
-                    #Field('recipient', notnull=True),
-                    msg_group_id,
-                    Field('subject', length=78),    # RFC 2822
-                    Field('body', 'text'),
-                    migrate=migrate)
-    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
-    #table.recipient.requires = IS_EMAIL()
-    #table.recipient.comment = SPAN("*", _class="req")
-    table.msg_group_id.label = T('Recipients')
-    table.subject.label = T('Subject')
-    table.body.label = T('Body')
-    SEND_EMAIL = T('Send Email')
-    VIEW_EMAIL_OUTBOX = T('View Email OutBox')
-    s3.crud_strings[tablename] = Storage(
-        title_create = SEND_EMAIL,
-        title_display = T('Email Details'),
-        title_list = VIEW_EMAIL_OUTBOX,
-        title_update = T('Edit Email'),
-        title_search = T('Search Email OutBox'),
-        subtitle_create = SEND_EMAIL,
-        subtitle_list = T('Email OutBox'),
-        label_list_button = VIEW_EMAIL_OUTBOX,
-        label_create_button = T('Send Email'),
-        msg_record_created = T('Email created'),
-        msg_record_modified = T('Email updated'),
-        msg_record_deleted = T('Email deleted'),
-        msg_list_empty = T('No Emails currently in OutBox'))
-
-    resource = 'email_sent'
-    tablename = "%s_%s" % (module, resource)
-    table = db.define_table(tablename, timestamp, authorstamp, uuidstamp, deletion_status,
-                    #Field('recipient', notnull=True),
-                    msg_group_id,
-                    Field('subject', length=78),    # RFC 2822
-                    Field('body', 'text'),
-                    migrate=migrate)
-    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
-    #table.recipient.requires = IS_EMAIL()
-    #table.recipient.comment = SPAN("*", _class="req")
-    table.msg_group_id.label = T('Recipients')
-    table.subject.label = T('Subject')
-    table.body.label = T('Body')
-    VIEW_SENT_EMAIL = T('View Sent Email')
-    s3.crud_strings[tablename] = Storage(
-        #title_create = T('Send Email'),
-        title_display = T('Email Details'),
-        title_list = VIEW_SENT_EMAIL,
-        #title_update = T('Edit Email'),
-        title_search = T('Search Sent Email'),
-        #subtitle_create = T('Send Email'),
-        subtitle_list = T('Sent Email'),
-        label_list_button = VIEW_SENT_EMAIL,
-        #label_create_button = T('Send Email'),
-        #msg_record_created = T('Email created'),
-        #msg_record_modified = T('Email updated'),
-        msg_record_deleted = T('Email deleted'),
-        msg_list_empty = T('No Emails currently in Sent'))
-
+                    Field('subject', length=78),    # RFC 2822
+                    Field('body', 'text'),
+                    Field("pr_message_method",
+                      "integer",
+                      requires = IS_IN_SET(pr_contact_method_opts),
+                      default = 1,
+                      label = T("Contact Method"),
+                      represent = lambda opt: pr_contact_method_opts.get(opt, UNKNOWN_OPT)),
+                    opt_msg_status,
+                    migrate=migrate)
+    table.uuid.requires = IS_NOT_IN_DB(db, '%s.uuid' % tablename)
+    table.pr_pe_id.label = T('Recipients ')
+    table.person_id.label = T('Sender')
+    table.subject.label = T('Subject')
+    table.body.label = T('Body')
+    SEND_MESSAGE = T('Send Message')
+    VIEW_MESSAGE_OUTBOX = T('View OutBox')
+    s3.crud_strings[tablename] = Storage(
+            title_create = SEND_MESSAGE,
+            title_display = T('Message Details'),
+            title_list = VIEW_MESSAGE_OUTBOX,
+            title_update = T('Edit Message'),
+            title_search = T('Search OutBox'),
+            subtitle_create = SEND_MESSAGE,
+            subtitle_list = T('OutBox'),
+            label_list_button = VIEW_MESSAGE_OUTBOX,
+            label_create_button = SEND_MESSAGE,
+            msg_record_created = T('Message created'),
+            msg_record_modified = T('Message updated'),
+            msg_record_deleted = T('Message deleted'),
+            msg_list_empty = T('No Message currently in your OutBox'))

=== modified file 'models/zzz_1st_run.py'
--- models/zzz_1st_run.py	2010-06-04 23:11:55 +0000
+++ models/zzz_1st_run.py	2010-06-06 09:09:51 +0000
@@ -233,10 +233,10 @@
             )
 
     # Messaging
-    tablename = 'mobile_setting'
+    tablename = 'mobile_settings'
     table = db[tablename]
-    if not db(table.id > 0).count():
-        table.insert(baud=115200)
+    if not db(table.id>0).count():
+        table.insert(modem_baud=115200)
 
     if shn_module_enable.get('msg', False):
         tablename = 'msg_setting'

=== added file 'modules/s3msg.py'
--- modules/s3msg.py	1970-01-01 00:00:00 +0000
+++ modules/s3msg.py	2010-06-06 09:09:51 +0000
@@ -0,0 +1,127 @@
+# -*- coding: utf-8 -*-
+# vim: ai ts=4 sts=4 et sw=4 encoding=utf-8
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be
+# included in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+
+__doc__ = \
+"""
+Module provides api to send messages - Currently SMS and Email
+
+"""
+
+__author__ = "Praneeth Bodduluri <lifeeth[at]gmail.com>"
+
+
+import urllib
+
+class Msg(object):
+	""" Toolkit for hooking into the Messaging framework"""
+	sms_api_post_config={}
+	sms_api_enabled = False
+	def __init__(self, environment, db=None, T=None, mail=None, modem=None):
+		self.db = db
+		self.sms_api = db(db.mobile_settings.modem_port == '').select()[0]
+		tmp_parameters = self.sms_api.parameters.split('&')
+		self.sms_api_enabled = self.sms_api.enabled
+		for tmp_parameter in tmp_parameters:
+			self.sms_api_post_config[tmp_parameter.split('=')[0]] = tmp_parameter.split('=')[1]
+		self.mail = mail
+		self.modem = modem
+		
+	def send_sms_via_modem(self,mobile,text = ''):
+		"""
+		Function to send SMS via MODEM
+		"""
+		self.modem.send_sms(mobile, text)
+
+	def send_sms_via_api(self,mobile,text = ''):
+		"""
+		Function to send SMS via API
+		"""
+		self.sms_api_post_config[self.sms_api.message_variable] = text
+		self.sms_api_post_config[self.sms_api.to_variable] = str(mobile)
+		query = urllib.urlencode(self.sms_api_post_config)
+		request = urllib.urlopen(self.sms_api.url, query)
+		output = request.read()
+		#print output
+	
+	def send_email_via_api(self,to,subject,message):
+		"""
+		Wrapper over web2py's email setup
+		"""
+		self.mail.send(to, subject, message)
+
+	def process_outbox(self, contact_method = 1, option = 1):
+		"""Send Pending Messages from OutBox.
+		If succesful then move from OutBox to Sent. A modified copy of send_email"""
+		table = self.db.msg_outbox
+		query = ((table.status == 1) & (table.pr_message_method == contact_method))
+		rows = self.db(query).select()
+		for row in rows:
+			status = True
+			contents = row.body
+			subject = row.subject
+			# Determine list of users
+			entity = row.pr_pe_id
+			table2 = self.db.pr_pentity
+			query = table2.id == entity
+			entity_type = self.db(query).select().first().opt_pr_entity_type
+			def send_pr_pe_id(pr_pe_id):
+				table3 = self.db.pr_pe_contact
+				query = (table3.pr_pe_id == pr_pe_id) & (table3.opt_pr_contact_method == contact_method)
+				recipient = self.db(query).select(table3.value,orderby = table3.priority).first()
+				if recipient:
+					try:
+						if (contact_method == 2 and option == 2):
+							self.send_sms_via_modem(recipient.value, contents)
+							return True
+						if (contact_method == 2 and option == 1):
+							self.send_sms_via_api(recipient.value, contents)
+							return True
+						if (contact_method == 1):
+							self.send_email_via_api(recipient.value,subject,contents)
+							return True
+					except:
+						return False
+			if entity_type == 2:
+				# V R HAZ GROUP
+				table3 = self.db.pr_group
+				query = (table3.pr_pe_id == entity)
+				group_id = self.db(query).select().first().id
+				table4 = self.db.pr_group_membership
+				query = (table4.group_id == group_id)
+				recipients = self.db(query).select()
+				for recipient in recipients:
+					person_id = recipient.person_id
+					table5 = self.db.pr_person
+					query = (table5.id == person_id)
+					pr_pe_id = self.db(query).select().first().pr_pe_id
+					status = send_pr_pe_id(pr_pe_id)
+			if entity_type == 1:
+				# We have a person 
+				status = send_pr_pe_id(entity)
+				# We only check status of last recipient
+			if status:
+				# Update status to sent in OutBox
+				self.db(table.id==row.id).update(status=2)
+				# Explicitly commit DB operations when running from Cron
+				self.db.commit()
+		return
\ No newline at end of file

=== modified file 'modules/sahana.py'
--- modules/sahana.py	2010-05-16 15:57:53 +0000
+++ modules/sahana.py	2010-06-06 09:09:51 +0000
@@ -371,7 +371,7 @@
                              readable=False, writable=False),
                     # TODO:
                     #   - Needs Validation if possible
-                    Field('mobile_phone', length=32,default=''),
+                    #Field('mobile_phone', length=32,default=''),
                     # add UTC Offset (+/-HHMM) to specify the user's timezone
                     # TODO:
                     #   - this could need a nice label and context help
@@ -390,6 +390,8 @@
                     Field('reset_password_key', length=512,
                             writable=False, readable=False, default='',
                             label=self.messages.label_registration_key),
+                    Field('timestamp', 'datetime', writable=False,
+                            readable=False,default=''),
                     migrate=\
                         self.__get_migrate(self.settings.table_user_name, migrate))
             else:
@@ -401,7 +403,7 @@
                             label=self.messages.label_last_name),
                     Field('person_uuid', length=64, default='',
                              readable=False, writable=False),
-                    Field('mobile_phone', length=32,default=''),
+                    #Field('mobile_phone', length=32,default=''),
                     # add UTC Offset (+/-HHMM) to specify the user's timezone
                     # TODO:
                     #   - this could need a nice label and context help
@@ -420,6 +422,8 @@
                     Field('reset_password_key', length=512,
                             writable=False, readable=False, default='',
                             label=self.messages.label_registration_key),
+                    Field('timestamp', 'datetime', writable=False,
+                            readable=False,default=''),
                     migrate=\
                         self.__get_migrate(self.settings.table_user_name, migrate))
             table = self.settings.table_user
@@ -813,7 +817,7 @@
         authenticated = self.id_group('Authenticated')
         self.add_membership(authenticated, form.vars.id)
 
-        # S3: Add to Person Registry as well
+        # S3: Add to Person Registry as well and Email to pr_pe_contact
         self.shn_link_to_person(user=form.vars)
 
 
@@ -850,6 +854,13 @@
                     if new_id:
                         person_uuid = db.pr_person[new_id].uuid
                         db(table.id==user.id).update(person_uuid=person_uuid)
+					# The following adds the email to pr_pe_contact
+                    db.pr_pe_contact.insert(
+                            pr_pe_id = pr_pe_id,
+                            opt_pr_contact_method = 1,
+                            priority = 1,
+                            value = email
+                            )
 
                 if self.user and self.user.id==user.id:
                     self.user.person_uuid=person_uuid

=== modified file 'views/mobile/settings_update.html'
--- views/mobile/settings_update.html	2010-02-14 01:51:37 +0000
+++ views/mobile/settings_update.html	2010-06-06 09:09:51 +0000
@@ -10,7 +10,3 @@
 {{pass}}
 </div>
 <p>&nbsp;</p>
-{{try:}}
- {{=list_btn}}
-{{except:}}
-{{pass}}

=== modified file 'views/msg/group_update.html'
--- views/msg/group_update.html	2010-06-04 23:50:19 +0000
+++ views/msg/group_update.html	2010-06-06 09:09:51 +0000
@@ -1,4 +1,3 @@
 {{extend "layout.html"}}
 {{include "_update.html"}}
 <p>&nbsp;</p>
-<a id="action-btn" href="{{=URL(r=request, f="group_user",args=request.args[1])}}">{{=T("Members")}}</a>

=== modified file 'views/msg/group_user_header.html'
--- views/msg/group_user_header.html	2010-02-14 01:51:37 +0000
+++ views/msg/group_user_header.html	2010-06-06 09:09:51 +0000
@@ -1,5 +1,4 @@
 {{=H2(title)}}
 <p>
-Type: {{=group_type}}
 </p>
 {{=P(description)}}

=== added file 'views/msg/outbox_create.html'
--- views/msg/outbox_create.html	1970-01-01 00:00:00 +0000
+++ views/msg/outbox_create.html	2010-06-06 09:09:51 +0000
@@ -0,0 +1,105 @@
+{{extend 'layout.html'}}
+{{try:}}
+ {{=H2(title)}}
+{{except:}}
+{{pass}}
+<script type="text/javascript">//<![CDATA[
+$(function() {
+    // Hide the real Input Field
+    $("#msg_outbox_pr_pe_id").hide();
+    // Autocomplete-enable the Dummy Input
+    $("#dummy").autocomplete('{{=URL(r=request, c='msg', f='search')}}', {
+        minChars: 2,
+		//mustMatch: true,
+		// TODO : Should get multiple working 
+		multiple: false,
+		matchContains: true,
+		autofill: true,
+		dataType: 'json',
+        parse: function(data) {
+            var rows = new Array();
+            for(var i=0; i<data.length; i++){
+                rows[i] = { data:data[i], value:data[i].id, result:data[i].name };
+            }
+            return rows;
+        },
+         formatItem: function(row, i, n) {
+             return row.name;
+ 		}
+    });
+    // Populate the real Input when the Dummy is selected
+    $("#dummy").result(function(event, data, formatted) {
+        var newvalue = data.id;
+        $("#msg_outbox_pr_pe_id").val(newvalue);
+    });
+//     $("#dummy_submit").click(function(){
+// 		return true;
+//     });
+});
+//]]></script>
+<div class='form-container'>
+{{try:}}
+ {{=form.custom.begin}}
+ <table>
+ <tbody>
+ <tr id='msg_outbox_pr_pe_id__row'>
+ <td>
+ <label>{{=form.custom.label.pr_pe_id}}</label>
+ </td>
+ <td>
+ {{=INPUT(_id="dummy", _class="ac_input", _size="50")}}
+  {{=form.custom.widget.pr_pe_id}}
+ </td>
+ <td>
+ {{=form.custom.comment.pr_pe_id}}
+ </td>
+</tr>
+ <tr id='msg_outbox_subject__row'>
+ <td>
+ <label>{{=form.custom.label.subject}}</label>
+ </td>
+ <td>
+ {{=form.custom.widget.subject}}
+ </td>
+ <td>
+ {{=form.custom.comment.subject}}
+ </td>
+ </tr>
+ <tr id='msg_outbox_body__row'>
+ <td>
+ <label>{{=form.custom.label.body}}</label>
+ </td>
+ <td>
+ {{=form.custom.widget.body}}
+ </td>
+ <td>
+ {{=form.custom.comment.body}}
+ </td>
+ </tr>
+  <tr id='msg_outbox_pr_message_method__row'>
+ <td>
+ <label>{{=form.custom.label.pr_message_method}}</label>
+ </td>
+ <td>
+ {{=form.custom.widget.pr_message_method}}
+ </td>
+ <td>
+ {{=form.custom.comment.pr_message_method}}
+ </td>
+ </tr>
+ <tr id='submit_record__row'>
+ <td>
+ </td>
+ <td>
+  {{=INPUT(_type="submit", _value=T('Send message'),_id="dummy_submit")}}
+ </td>
+ </tr>
+ <td>
+ </td>
+ </tbody>
+ </table>
+ {{=form.custom.end}}
+{{except:}}
+{{pass}}
+</div>
+<p>&nbsp;</p>

